/******************************************************************************
 *  include files
 *****************************************************************************/
#include "aq3.h"
#include "i2c_simple_master.h"
#include "../application/parameters.h"
#include "port.h"
#include "clock_config.h"
#include <util/delay.h>
#include <i2c_master.h>

/******************************************************************************
 *  macro definitions
 *****************************************************************************/
#define Wake_set_level(state)      PORTC_set_pin_level(3, (state)) // CS

/* CCS811 register addresses */
#define CCS811_REG_STATUS          (0x00)
#define CCS811_REG_MEAS_MODE       (0x01)
#define CCS811_REG_ALG_RESULT_DATA (0x02)
#define CCS811_REG_RAW_DATA        (0x03)
#define CCS811_REG_ENV_DATA        (0x05)
#define CCS811_REG_NTC             (0x06)
#define CCS811_REG_THRESHOLDS      (0x10)
#define CCS811_REG_BASELINE        (0x11)

#define CCS811_REG_HW_ID           (0x20)
#define CCS811_REG_HW_VER          (0x21)
#define CCS811_REG_FW_BOOT_VER     (0x23)
#define CCS811_REG_FW_APP_VER      (0x24)

#define CCS811_REG_ERROR_ID        (0xe0)

#define CCS811_REG_APP_ERASE       (0xf1)
#define CCS811_REG_APP_DATA        (0xf2)
#define CCS811_REG_APP_VERIFY      (0xf3)
#define CCS811_REG_APP_START       (0xf4)
#define CCS811_REG_SW_RESET        (0xff)

// status register bits
#define CCS811_STATUS_ERROR        (0x01)  // error, details in CCS811_REG_ERROR
#define CCS811_STATUS_DATA_RDY     (0x08)  // new data sample in ALG_RESULT_DATA
#define CCS811_STATUS_APP_VALID    (0x10)  // valid application firmware loaded
#define CCS811_STATUS_FW_MODE      (0x80)  // firmware is in application mode

#define CCS811_ALG_DATA_ECO2_HB   (0)
#define CCS811_ALG_DATA_ECO2_LB   (1)
#define CCS811_ALG_DATA_TVOC_HB   (2)
#define CCS811_ALG_DATA_TVOC_LB   (3)
#define CCS811_ALG_DATA_STATUS    (4)
#define CCS811_ALG_DATA_ERROR_ID  (5)
#define CCS811_ALG_DATA_RAW_HB    (6)
#define CCS811_ALG_DATA_RAW_LB    (7)

/*******************************************************************************
* @Name
*    uint8_t ccs811_InitSensor(void)
* @Param
*    none
* @Returns
*    initialization status
* @Description
*     sensor initialization   
 *******************************************************************************/

void ccs811_InitSensor(void)
{
    const static uint32_t sw_reset = 0x8a72e511;
    static uint8_t app_start = CCS811_REG_APP_START;
    
    Wake_set_level(false); 
    
    
    //perform software reset
    I2C_0_write4ByteRegister(CCS811_I2C_ADDRESS_1, CCS811_REG_SW_RESET, sw_reset);

    // wait 100 ms after the reset
    _delay_ms(100);

    // swtich to application mode
    I2C_0_writeNBytes(CCS811_I2C_ADDRESS_1, &app_start, 1);
    
    // wait 100 ms after starting the app
    _delay_ms(100);
        
    
    // try to set default measurement mode to *ccs811_mode_1s*  
	I2C_0_write1ByteRegister(CCS811_I2C_ADDRESS_1, CCS811_REG_MEAS_MODE, ccs811_mode_1s);
	
	_delay_ms(100);
    
    Wake_set_level(true); 

}


/*******************************************************************************
* @Name
*    uint8_t ccs811_GetResults (uint16_t* iaq_eco2,uint16_t* iaq_tvoc)
* @Param
*    address of variables at which data has to be stored  
* @Returns
*    read status
* @Description
*    read data from sensor    
 *******************************************************************************/
void ccs811_GetResults (uint16_t* iaq_eco2,uint16_t* iaq_tvoc)
{
    Wake_set_level(false); 

    uint8_t data[8] = {0};

    // read IAQ sensor values and RAW sensor data including status and error id
    I2C_0_readDataBlock(CCS811_I2C_ADDRESS_1, CCS811_REG_ALG_RESULT_DATA, data, 8);

    // if *iaq* is not NULL return IAQ sensor values
     *iaq_tvoc = data[CCS811_ALG_DATA_TVOC_HB] << 8 | data[CCS811_ALG_DATA_TVOC_LB];
     *iaq_eco2 = data[CCS811_ALG_DATA_ECO2_HB] << 8 | data[CCS811_ALG_DATA_ECO2_LB];
     
      Wake_set_level(true); 
    
}



/*******************************************************************************
   Below two function are part of i2c drivers. Reason to define the functions 
   here is, these functions are not generated by Atmel START, but required for 
   Air Quality 3 driver. 
 *******************************************************************************/
static i2c_operations_t I2C_0_wr4RegCompleteHandler(void *p)
{
	I2C_0_set_buffer(p, 4);
	I2C_0_set_data_complete_callback(NULL, NULL);
	return i2c_continue;
}

void I2C_0_write4ByteRegister(i2c_address_t address, uint8_t reg, uint32_t data)
{
	while (!I2C_0_open(address))
	; // sit here until we get the bus..
	I2C_0_set_data_complete_callback(I2C_0_wr4RegCompleteHandler, &data);
	I2C_0_set_buffer(&reg, 1);
	I2C_0_set_address_nack_callback(i2c_cb_restart_write, NULL); // NACK polling?
	I2C_0_master_write();
	while (I2C_BUSY == I2C_0_close())
	; // sit here until finished.
	
}

/*******************************************************************************/
   



